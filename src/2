mod config;
mod utils;
use blogworm::Summary;
use indicatif::ProgressBar;
use blogworm::POSTSRC_LIST;
use tokio::task;
use utils::timestamp_to_readable;
use std::fs::{self, File};
use std::collections::HashMap;
use std::io::{self, Read, Write};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {

    let (last_timestamp, current_timestamp) = checktimestamp().unwrap();
    
    let mut tasks = vec![];
    println!("[+] Starting update post link...");
    for postsrc in POSTSRC_LIST.iter() {
        println!("PostSrc: {}", postsrc.summarize());

        let task = task::spawn(async {
            match utils::get_blog_link_from_postsrc(postsrc).await {
                Ok(result) => {
                    let (website, post_list) = result;
                    let temp_url = website.split('/').take(3).collect::<Vec<&str>>().join("/");
                    
                    for post_link in post_list {
                        let target =temp_url + post_link.as_str();
                        utils::get_post_from_link(&target, &postsrc);
                    } 
                    println!("[*] Success Update All PostSrc !");
                }
                Err(error) => {
                    eprintln!("Error: {}", error);
                }
            }
        });
        tasks.push(task);

    }
    let bar = ProgressBar::new(tasks.len().try_into().unwrap());
    for task in tasks {
        bar.inc(1);
        match task.await.expect("Failed to join task") {
            (result) => {
                println!("[!!!!]{:?}",result);
            }
        };
    }
    bar.finish();
    let config: config::args::Config =  config::args::get_configs().unwrap();


    let blog_url = config.get_blog_url();
    let body = utils::send_request(blog_url.to_string()).await;
    match body {
        Ok(body) => {
            println!("Response body: {}", body);

        }
        Err(error) => {
            eprintln!("Error: {}",error);
        }
    }
    Ok(())
}

fn checktimestamp() -> io::Result<(u64, u64)>{

    let home_dir = dirs::home_dir().ok_or_else(|| io::Error::new(io::ErrorKind::NotFound, "Can't get user hoem dir"))?;
    let mut app_dir = home_dir.clone();
    app_dir.push(".blogworm");
    fs::create_dir_all(&app_dir)?;

    let mut timestamp_file = app_dir.clone();
    timestamp_file.push("timestamp");

    let current_timestamp = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .expect("Failed to get system time")
        .as_secs();

    if !timestamp_file.exists() {
        let mut file = File::create(&timestamp_file)?;
        file.write_all(current_timestamp.to_string().as_bytes())?;
        println!("[*] It seems you frist times to run blogworm or timestamp file deleted");
        let datetime = timestamp_to_readable(current_timestamp);
        println!("[*] Current run blogworm AT: {}", datetime.format("%Y-%m-%d %H:%M:%S"));
        Ok((0, current_timestamp))

    } else {
        let mut file = File::open(&timestamp_file)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        let mut file = File::create(&timestamp_file)?;
        file.write_all(current_timestamp.to_string().as_bytes())?;
        let last_timestamp = contents.trim().parse::<u64>().map_err(|err| io::Error::new(io::ErrorKind::InvalidData, err))?;

        let mut datetime = timestamp_to_readable(last_timestamp);
        println!("[*] Last run blogworm AT: {}", datetime.format("%Y-%m-%d %H:%M:%S"));
        datetime = timestamp_to_readable(current_timestamp);
        println!("[*] Current run blogworm AT: {}", datetime.format("%Y-%m-%d %H:%M:%S"));
        Ok((last_timestamp, current_timestamp))

    }

}

